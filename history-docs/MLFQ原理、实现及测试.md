# MLFQ算法原理、实现及测试

`多级队列反馈调度(Multi-Level Feedback Queue, MLFQ)`算法在1962年首次被提出，用于`兼容分时操作系统（Compatible Time-Sharing System, CTSS）`。在这种算法注重的场景下，既有交互式短任务，又有CPU密集型的长任务。因此，算法的目标是既要优化交互式任务的**响应时间**，又要让CPU密集型任务有足够长的时间运行，一定程度上降低**周转时间**。

## 原理

首先，考虑如果我们已经知道了所有进程的特征，应该怎么做。很显然，只要存在准备好的交互式进程，就要优先响应它们；而对于交互式进程，应该采用时间片轮转(RR)的方式调度，以降低响应时间。对计算密集型进程，为公平和统一起见，不妨也采用RR算法；但这时不需要低响应时间，因此我们可以适当增加时间片大小。这样，我们就抽象出了一个优先级的模型：交互式进程设为高优先级，CPU密集型设为低优先级；同优先级采用RR调度，且时间片大小与优先级负相关。当然，交互式或计算型任务并不是简单的二分类，因此我们可以适当增加优先级的数量。这其实就是基本的固定优先级的多级无反馈队列调度。

但很显然，我们并不能一开始知道每个进程的特点；同时，交互式/计算式也不是固定的性质：一个程序完全可以一段时间内表现为交互式，一段时间表现为计算型任务。因此，*Corbato*提出了MLFQ这种调度方式。这种算法的思想是**以史为鉴**，通过进程过去一段时间内的表现，估计进程的特征，据此动态调整其优先级。其基于上面的多级队列调度，且基本规则如下：

- 进程进入系统时，放在最高优先级（最上层队列）。
- 如果进程用完整个时间片，降低其优先级。否则（时间片结束前主动让出CPU），保持在相同优先级不变。

这样，交互式进程会停留在顶层，获得最快的响应时间，而长进程降到底层，获得更多的CPU时间，实现了我们的目标。另外，考虑当没有交互式进程的特殊情况，所有进程会同时下降其优先级，短进程一段时间内运行完毕，而长进程降到底层轮转运行；由于高优先级时间片较小，这其实一定程度上近似了SJF调度，使得周转时间的指标也得到了优化。

目前的调度仍然存在两个问题。首先，如果存在大量交互式进程，就会出现饥饿问题；另外，程序从计算式进程转到交互式进程的情况并没有被考虑到。我们只要加入最后一个规则：每经过一段时间 S，将系统中所有工作重新加入最高优先级队列。这样，两个问题都得到了解决。

最后，调度最难的部分其实仍然是设置一个合理的参数。虽然比起教材上抽象的描述，我们已经确定了十分具体的调度方案，但仍然有三个重要的参数需要设置：队列数量，时间片与优先级关系，以及优先级重置时间。大多数MLFQ调度的实现都动态配置这三个参数，例如Solaris提供了一组管理员可修改的表来决定它们。该表默认有60层队列， 时间片长度从20毫秒（最高优先级），到几百毫秒（最低优先级），每一秒左右提升一次进程的优先级。

